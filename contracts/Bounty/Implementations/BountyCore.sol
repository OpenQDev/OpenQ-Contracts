// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.17;

import '../Storage/BountyStorageCore.sol';

/**
 * @title BountyCore
 * @dev BountyCore Version 1
 */
abstract contract BountyCore is BountyStorageCore {
    /**
     * INITIALIZATION
     */

    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address payable;
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;

    // EXTERNAL SETTERS

    /**
     * @dev Creates a deposit and transfers tokens from msg.sender to this contract
     * @param _funder The funder's address
     * @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)
     * @param _volume The volume of token to transfer
     * @param _expiration The duration until the deposit becomes refundable
     * @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty
     */
    function receiveFunds(
        address _funder,
        address _tokenAddress,
        uint256 _volume,
        uint256 _expiration
    )
        external
        payable
        override
        onlyDepositManager
        nonReentrant
        returns (bytes32, uint256)
    {
        require(_volume != 0, Errors.ZERO_VOLUME_SENT);
        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);
        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);

        bytes32 depositId = _generateDepositId();

        uint256 volumeReceived;
        if (_tokenAddress == address(0)) {
            volumeReceived = msg.value;
        } else {
            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);
        }

        funder[depositId] = _funder;
        tokenAddress[depositId] = _tokenAddress;
        volume[depositId] = volumeReceived;
        depositTime[depositId] = block.timestamp;
        expiration[depositId] = _expiration;
        isNFT[depositId] = false;

        deposits.push(depositId);
        tokenAddresses.add(_tokenAddress);

        return (depositId, volumeReceived);
    }

    /**
     * @dev Transfers volume of deposit or NFT of deposit from bounty to funder
     * @param _depositId The deposit to refund
     * @param _funder The initial funder of the deposit
     * @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)
     */
    function refundDeposit(
        bytes32 _depositId,
        address _funder,
        uint256 _volume
    ) external onlyDepositManager nonReentrant {
        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);
        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);
        require(
            block.timestamp >= depositTime[_depositId] + expiration[_depositId],
            Errors.PREMATURE_REFUND_REQUEST
        );

        refunded[_depositId] = true;

        if (tokenAddress[_depositId] == address(0)) {
            _transferProtocolToken(funder[_depositId], _volume);
        } else if (isNFT[_depositId]) {
            _transferNft(
                tokenAddress[_depositId],
                funder[_depositId],
                tokenId[_depositId]
            );
        } else {
            _transferERC20(
                tokenAddress[_depositId],
                funder[_depositId],
                _volume
            );
        }
    }

    /**
     * @dev Extends deposit duration
     * @param _depositId The deposit to extend
     * @param _seconds Number of seconds to extend deposit
     * @param _funder The initial funder of the deposit
     */
    function extendDeposit(
        bytes32 _depositId,
        uint256 _seconds,
        address _funder
    ) external onlyDepositManager nonReentrant returns (uint256) {
        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);
        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);
        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);

        if (
            block.timestamp > depositTime[_depositId] + expiration[_depositId]
        ) {
            expiration[_depositId] =
                block.timestamp -
                depositTime[_depositId] +
                _seconds;
        } else {
            expiration[_depositId] = expiration[_depositId] + _seconds;
        }

        return expiration[_depositId];
    }

    /**
     * @dev Transfers NFT from bounty address to _payoutAddress
     * @param _payoutAddress The destination address for the NFT
     * @param _depositId The payout address of the bounty
     */
    function claimNft(address _payoutAddress, bytes32 _depositId)
        external
        onlyClaimManager
        nonReentrant
    {
        _transferNft(
            tokenAddress[_depositId],
            _payoutAddress,
            tokenId[_depositId]
        );
    }

    /**
     * @dev Sets the funding goal
     * @param _fundingToken Token address for funding goal
     * @param _fundingGoal Token volume for funding goal
     */
    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)
        external
        virtual
        onlyOpenQ
    {
        fundingGoal = _fundingGoal;
        fundingToken = _fundingToken;
        hasFundingGoal = true;
    }

    /**
     * @dev Whether or not KYC is required to fund and claim the bounty
     * @param _kycRequired Whether or not KYC is required to fund and claim the bounty
     */
    function setKycRequired(bool _kycRequired) external onlyOpenQ {
        kycRequired = _kycRequired;
    }

    /**
     * @dev Whether or not the Bounty is invoiceable
     * @param _invoiceable Whether or not the Bounty is invoiceable
     */
    function setInvoiceable(bool _invoiceable) external onlyOpenQ {
        invoiceable = _invoiceable;
    }

    /**
     * @dev Whether or not KYC is required to fund and claim the bounty
     * @param _supportingDocuments Whether or not KYC is required to fund and claim the bounty
     */
    function setSupportingDocuments(bool _supportingDocuments)
        external
        onlyOpenQ
    {
        supportingDocuments = _supportingDocuments;
    }

    // INTERNAL HELPERS

    /**
     * @dev Transfers _volume of both ERC20 or protocol token to _payoutAddress
     * @param _tokenAddress Address of an ERC20 or Zero Address for protocol token
     * @param _volume Volume to transfer
     * @param _payoutAddress Destination address
     */
    function _transferToken(
        address _tokenAddress,
        uint256 _volume,
        address _payoutAddress
    ) internal {
        if (_tokenAddress == address(0)) {
            _transferProtocolToken(_payoutAddress, _volume);
        } else {
            _transferERC20(_tokenAddress, _payoutAddress, _volume);
        }
    }

    /**
     * @dev Receives _volume of ERC20 at _tokenAddress from _funder to bounty address
     * @param _tokenAddress The ERC20 token address
     * @param _funder The funder of the bounty
     * @param _volume The volume of token to transfer
     */
    function _receiveERC20(
        address _tokenAddress,
        address _funder,
        uint256 _volume
    ) internal returns (uint256) {
        uint256 balanceBefore = getERC20Balance(_tokenAddress);
        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
        token.safeTransferFrom(_funder, address(this), _volume);
        uint256 balanceAfter = getERC20Balance(_tokenAddress);
        require(
            balanceAfter >= balanceBefore,
            Errors.TOKEN_TRANSFER_IN_OVERFLOW
        );

        /* The reason we take the balanceBefore and balanceAfter rather than the raw volume
         * is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.
         * Therefore the volume received after transferFrom can be lower than the raw volume sent by the sender */
        return balanceAfter - balanceBefore;
    }

    /**
     * @dev Transfers _volume of ERC20 at _tokenAddress from bounty address to _funder
     * @param _tokenAddress The ERC20 token address
     * @param _payoutAddress The destination address of the funds
     * @param _volume The volume of token to transfer
     */
    function _transferERC20(
        address _tokenAddress,
        address _payoutAddress,
        uint256 _volume
    ) internal {
        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
        token.safeTransfer(_payoutAddress, _volume);
    }

    /**
     * @dev Transfers _volume of protocol token from bounty address to _payoutAddress
     * @param _payoutAddress The destination address of the funds
     * @param _volume The volume of token to transfer
     */
    function _transferProtocolToken(address _payoutAddress, uint256 _volume)
        internal
    {
        payable(_payoutAddress).sendValue(_volume);
    }

    /**
     * @dev Receives NFT of _tokenId on _tokenAddress from _funder to bounty address
     * @param _tokenAddress The ERC721 token address
     * @param _sender The sender of the NFT
     * @param _tokenId The tokenId
     */
    function _receiveNft(
        address _tokenAddress,
        address _sender,
        uint256 _tokenId
    ) internal {
        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);
        nft.safeTransferFrom(_sender, address(this), _tokenId);
    }

    /**
     * @dev Transfers NFT of _tokenId on _tokenAddress from bounty address to _payoutAddress
     * @param _tokenAddress The ERC721 token address
     * @param _payoutAddress The sender of the NFT
     * @param _tokenId The tokenId
     */
    function _transferNft(
        address _tokenAddress,
        address _payoutAddress,
        uint256 _tokenId
    ) internal {
        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);
        nft.safeTransferFrom(address(this), _payoutAddress, _tokenId);
    }

    /**
     * UTILITY
     */

    /**
     * @dev Generates a unique deposit ID from bountyId and the current length of deposits
     */
    function _generateDepositId() internal view returns (bytes32) {
        return keccak256(abi.encode(bountyId, deposits.length));
    }

    /**
     * @dev Generates a unique claimant ID from user and asset
     */
    function _generateClaimantId(
        string memory claimant,
        string memory claimantAsset
    ) internal pure returns (bytes32) {
        return keccak256(abi.encode(claimant, claimantAsset));
    }

    // PUBLIC GETTERS

    /**
     * TRANSFER HELPERS
     */

    /**
     * @dev Returns token balance for both ERC20 or protocol token
     * @param _tokenAddress Address of an ERC20 or Zero Address for protocol token
     */
    function getTokenBalance(address _tokenAddress)
        public
        view
        returns (uint256)
    {
        if (_tokenAddress == address(0)) {
            return address(this).balance;
        } else {
            return getERC20Balance(_tokenAddress);
        }
    }

    /**
     * @dev Returns the ERC20 balance for this bounty address
     * @param _tokenAddress The ERC20 token address
     * @return balance The ERC20 balance for this bounty address
     */
    function getERC20Balance(address _tokenAddress)
        public
        view
        returns (uint256 balance)
    {
        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
        return token.balanceOf(address(this));
    }

    /**
     * @dev Returns an array of all deposits (ERC20, protocol token, and NFT) for this bounty
     * @return deposits The array of deposits including ERC20, protocol token, and NFT
     */
    function getDeposits() external view returns (bytes32[] memory) {
        return deposits;
    }

    /**
     * @dev Returns an array of ONLY NFT deposits for this bounty
     * @return nftDeposits The array of NFT deposits
     */
    function getNftDeposits() external view returns (bytes32[] memory) {
        return nftDeposits;
    }

    /**
     * @dev Returns an array of all ERC20 token addresses which have funded this bounty
     * @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty
     */
    function getTokenAddresses() public view returns (address[] memory) {
        return tokenAddresses.values();
    }

    /**
     * @dev Returns the total number of unique tokens deposited on the bounty
     * @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty
     */
    function getTokenAddressesCount() external view returns (uint256) {
        return tokenAddresses.values().length;
    }

    /**
     * @dev Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds
     * @param _depositId The depositId that determines which token is being looked at
     * @return uint256
     */
    function getLockedFunds(address _depositId) public view returns (uint256) {
        uint256 lockedFunds;
        bytes32[] memory depList = this.getDeposits();
        for (uint256 i = 0; i < depList.length; i++) {
            if (
                block.timestamp <
                depositTime[depList[i]] + expiration[depList[i]] &&
                tokenAddress[depList[i]] == _depositId
            ) {
                lockedFunds += volume[depList[i]];
            }
        }

        return lockedFunds;
    }
}
